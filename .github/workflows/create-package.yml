# Unique name for this workflow
name: master

# Definition when the workflow should run
on:
  push:
    branches:
      - master
    paths:
      - "force-app/**"

# Jobs to be executed
jobs:
  packaging:
    name: Create new package
    runs-on: ubuntu-latest
    steps:
      # Install Salesforce CLI
      - name: "Install Salesforce CLI" # TODO implement https://github.com/marketplace/actions/salesforce-sfdx-cli-action
        run: |
          wget https://developer.salesforce.com/media/salesforce-cli/sfdx-linux-amd64.tar.xz
          mkdir sfdx-cli
          tar xJf sfdx-linux-amd64.tar.xz -C sfdx-cli --strip-components 1
          ./sfdx-cli/install

      # Checkout the code in the pull request
      - name: "Checkout source code"
        uses: actions/checkout@v2

      # Store secret for dev hub
      - name: "Populate auth file with PROD_SFDX_URL secret"
        shell: bash
        run: "echo ${{ secrets.PROD_SFDX_URL}} > ./PROD_SFDX_URL.txt"

      # Store secret for package target org installation
      - name: "Populate auth file with INTEGRATION_SANDBOX_SFDX_URL secret"
        shell: bash
        run: "echo ${{ secrets.INTEGRATION_SANDBOX_SFDX_URL}} > ./INTEGRATION_SANDBOX_SFDX_URL.txt"

      # Store secret for package target org installation
      - name: "Populate auth file with DEV_SFDX_URL secret"
        shell: bash
        run: "echo ${{ secrets.DEV_SFDX_URL}} > ./DEV_SFDX_URL.txt"

      # Authenticate dev hub
      - name: "Authenticate Dev Hub"
        run: "sfdx force:auth:sfdxurl:store -f ./PROD_SFDX_URL.txt -a devhub -d"

      # Authenticate integration sandbox
      - name: "Authenticate package target org"
        run: "sfdx force:auth:sfdxurl:store -f ./INTEGRATION_SANDBOX_SFDX_URL.txt -a integration-sandbox -s"

      # Authenticate dev sandbox
      - name: "Authenticate package target org"
        run: "sfdx force:auth:sfdxurl:store -f ./DEV_SFDX_URL.txt -a dev -s"

      # Remove auth files
      - name: "Remove auth files"
        if: always()
        run: |
          rm -f ./PROD_SFDX_URL.txt
          rm -f ./INTEGRATION_SANDBOX_SFDX_URL.txt
          rm -f ./DEV_SFDX_URL.txt

      # Delete unpackagable
      - name: "Delete unpackagable"
        run: rm -rf unpackagable

      # Create package version
      - name: "Create package version"
        id: package-version-create
        run: |
          json=$(sfdx force:package:version:create -f config/project-scratch-def.json -p $(cat sfdx-project.json | jq '.packageDirectories[0].package' -r) -k ${{ secrets.PACKAGE_KEY }} -w 90 --json)
          echo $json
          echo "::set-output name=result::$(echo $json | jq -c .)"

          status=$(echo $json |jq '.status')
          if [[ "$status" = "0" ]]
          then
            echo "::set-output name=isSuccess::true"
          else
            echo "::set-output name=isSuccess::false"
          fi

      # Extract data from package version create result
      - name: "Extract package:version:create result data"
        id: extract-data-package-version-create
        uses: muenzpraeger/github-action-extract-sfdx-packaging-result@master
        with:
          json: ${{steps.package-version-create.outputs.result}}

      # Install sfpowerkit plugin used to install multiple packages only by version number
      - name: "Install sfpowerkit plugin"
        run: "echo y | sfdx plugins:install sfpowerkit"

      # Install packages this repo is dependant on
      - name: "Install dependant packages"
        run: "sfdx sfpowerkit:package:dependencies:install -u dev -r -a -w 60 -k '1:${{ secrets.PACKAGE_KEY }} 2:${{ secrets.PACKAGE_KEY }} 3:${{ secrets.PACKAGE_KEY }} 4:${{ secrets.PACKAGE_KEY }} 5:${{ secrets.PACKAGE_KEY }} 6:${{ secrets.PACKAGE_KEY }} 7:${{ secrets.PACKAGE_KEY }} 8:${{ secrets.PACKAGE_KEY }} 9:${{ secrets.PACKAGE_KEY }} 10:${{ secrets.PACKAGE_KEY }}'"

      # Install new package version into dev sandbox
      - name: "Install new package version into dev sandbox"
        if: success()
        run: sfdx force:package:install --package ${{ steps.extract-data-package-version-create.outputs.packageVersionId }} -w 20 -b 20 -u dev -r -k ${{ secrets.PACKAGE_KEY }} --json

      # Install new package version into integration org
      - name: "Install new package version into integration org"
        if: success() || (failure() && steps.extract-data-package-version-create.outputs.isSuccess)
        id: install-package-version-to-integration
        run: |
          json=$(sfdx force:package:install --package ${{ steps.extract-data-package-version-create.outputs.packageVersionId }} -w 20 -b 20 -u integration-sandbox -r -k ${{ secrets.PACKAGE_KEY }} --json)
          echo $json

          status=$(echo $json |jq '.status')
          if [[ "$status" = "0" ]]
          then
            echo "::set-output name=isSuccess::true"
          else
            echo "::set-output name=isSuccess::false"
          fi

      # Fetch beta version number
      - name: "Fetch beta version number"
        if: success() || (failure() && steps.package-version-create.outputs.isSuccess)
        id: packaging-updater
        uses: muenzpraeger/github-action-sfdx-packaging-updater@master

      # set release variables
      - name: "Set release fields"
        if: success() || (failure() && steps.package-version-create.outputs.isSuccess)
        id: release-fields
        run: |
          versionNumber=$(cat sfdx-project.json | jq '.packageDirectories[0].versionNumber' -r | sed 's/.\{5\}$//')
          packageAliases=$(cat sfdx-project.json | jq '.packageAliases | keys_unsorted[-1]' -r | sed 's/.*-//')

          echo "::set-output name=tagName::v$(echo $versionNumber)-beta$(echo $packageAliases)"
          echo "::set-output name=releaseName::$(echo $versionNumber)-beta$(echo $packageAliases)"
          echo "::set-output name=bodyVersion::$(echo $versionNumber).$(echo $packageAliases)"
          echo "::set-output name=bodyPackage::${{ steps.extract-data-package-version-create.outputs.packageVersionId }}"

      # Generate changelog from commits
      # TODO check if dev sandbox failed
      - name: Generate changelog
        id: changelog
        uses: metcalfc/changelog-generator@v0.2.3
        with:
          myToken: ${{ secrets.GITHUB_TOKEN }}

      # create github release
      - name: "Create Release - Success"
        if: success() && steps.package-version-create.outputs.isSuccess && steps.install-package-version-to-integration.outputs.isSuccess
        uses: actions/create-release@latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.release-fields.outputs.tagName }}
          release_name: ${{ steps.release-fields.outputs.releaseName }}
          body: |
            **Version**: ${{ steps.release-fields.outputs.bodyVersion }}
            **Package ID**: ${{ steps.release-fields.outputs.bodyPackage }}
            **Author**: ${{ github.actor }}

            ✅ Package Creation
            ✅ Package Installation

            ## Changelog

            ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: true

      # create github release
      - name: "Create Release - Failed to install"
        if: failure() && steps.package-version-create.outputs.isSuccess && !steps.install-package-version-to-integration.outputs.isSuccess
        uses: actions/create-release@latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.release-fields.outputs.tagName }}
          release_name: ${{ steps.release-fields.outputs.releaseName }}
          body: |
            **Version**: ${{ steps.release-fields.outputs.bodyVersion }}
            **Package ID**: ${{ steps.release-fields.outputs.bodyPackage }}
            **Author**: ${{ github.actor }}

            ✅ Package Creation
            ❌ Package Installation

            ## Changelog

            ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: true
